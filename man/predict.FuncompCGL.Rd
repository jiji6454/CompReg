% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{predict.FuncompCGL}
\alias{predict.FuncompCGL}
\title{make predictions from a "FuncompCGL" object}
\usage{
\method{predict}{FuncompCGL}(object, newx, newZc = NULL, intercept = TRUE,
  s = NULL, ref = NULL, degree = 3, basis_fun, insert, method, interval,
  Trange, T.name, ID.name, ...)
}
\arguments{
\item{object}{fitted \code{\link{FuncompCGL}} object.}

\item{newx}{Data frame of new values for functional compositional data which predictions are to be made.}

\item{newZc}{Matrix of new values for time-invariate covariates which predictions are to be made.}

\item{intercept}{whether to include intercept. Default is TRUE.}

\item{s}{value(s) of the penalty parameter \code{lam} at which predictions are required.
Default is the entire sequence used to create the model.}

\item{ref}{reference variable. If \code{ref} is set to a scalar between \code{[1,p]}, log-contract method is applied with the variable
\code{ref} as baseline. If \code{ref} = \code{NULL} (default value), constrained group lasso method is applied}

\item{degree}{degree of basis - default value is 3.}

\item{basis_fun}{a function of basis. For now one of the following three types,
\itemize{
\item \code{bs} B-splines see \code{\link{bs}}.
\item \code{OBasis} Orthoganal B-splies, see \code{\link{orthogonalsplinebasis}}.
\item \code{fourier} Fourier basis, see \code{\link{fda}}
}
Default is \code{"bs"}.}

\item{insert}{way to interpolation. If \code{insert} = \code{"X"} or \code{"basis"}, dense time sequence is generated, equally space
by \code{min(diff(sseq))/20)}, where \code{sseq} is sorted set of all observed time points.
\itemize{
\item \code{"FALSE"} no interpolation.
\item \code{"X"} linear interpolation of compositional data.
\item \code{"basis"} compositional data is considered as step function, imposing basis on un-observed time points for each subject.
}
Default is \code{"FALSE"}}

\item{method}{method used to approximate integral.
\itemize{
\item \code{"trapezoidal"} Sum up area under trapezoidal formulated by values of function at two adjacent observed time points. See \code{\link{ITG_trap}}.
\item \code{"step"} Sum up area under rectangle formulated by step function at observed time points. See \code{\link{ITG_step}}.
}
Default is \code{"trapezoidal"}}

\item{interval}{a character string sepcifying domain of integral
\itemize{
  \item "Original" On original time scale, interval = range(Time).
  \item "Standard" Time points are mapped onto [0,1], interval = (0,1).
}
Default is \code{"Original"}}

\item{Trange}{range of time points}

\item{T.name}{characters specifying names of time varaible and Subject ID respectively in X,
only needed as X is data frame of longitudinal compositinal varaibles.
Default are \code{"TIME"} and \code{"Subject_ID"}.}

\item{ID.name}{characters specifying names of time varaible and Subject ID respectively in X,
only needed as X is data frame of longitudinal compositinal varaibles.
Default are \code{"TIME"} and \code{"Subject_ID"}.}

\item{\dots}{Not used. Other arguments to predict.}
}
\value{
prediction values at the requested values for \code{s}.
}
\description{
predicts fitted values and class labels from a fitted \code{\link{FuncompCGL}} object.
}
\details{
\code{s} is the new vector at which predictions are requested. If \code{s} is not in the lambda
       sequence used for fitting the model, the \code{predict} function will use linear interpolation
       to make predictions. The new values are interpolated using a fraction of predicted values from
       both left and right \code{lam} indices.
}
\examples{

df_beta = 5
p = 30
beta_C_true = matrix(0, nrow = p, ncol = df_beta)
beta_C_true[3, ] <- c(-0.8, -0.8 , 0.4 , 1 , 1)
beta_C_true[4, ] <- c(0.5, 0.5, -0.6  ,-0.6, -0.6)
beta_C_true[1, ] <- c(-0.5, -0.5, -0.5 , -1, -1)
beta_C_true[2, ] <- c(0.8, 0.8,  0.7,  0.6,  0.6)
Data <- Model(n = 50, p = p, m = 2, intercept = TRUE,
              SNR = 2, sigma = 2,
              rho_X = 0, rho_T = 0.5, df_beta = df_beta,
              n_T = 20, obs_spar = 0.8, theta.add = c(3,4,5),
              beta_C = as.vector(t(beta_C_true)))
TEST <- Model(n = 100, p = p, m = 2, intercept = TRUE,
              SNR = 2, sigma = 2,
              rho_X = 0, rho_T = 0.5, df_beta = df_beta,
              n_T = 20, obs_spar = 0.8, theta.add = c(3,4,5),
              beta_C = as.vector(t(beta_C_true)))
y <- Data$data$y
X <- Data$data$Comp
Zc <- Data$data$Zc
intercept <- Data$data$intercept

k_use <- df_beta
m1 <- FuncompCGL(y = y, X = X , Zc = Zc, intercept = intercept,
                 k = k_use, basis_fun = "bs",
                 insert = "FALSE", method = "t",
                 dfmax = p, tol = 1e-6)
predict(m1, newx = TEST$data$Comp, newZc = TEST$data$Zc, intercept = intercept)
}
\seealso{
\code{\link{FuncompCGL}}
}
