% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{predict.GIC.FuncompCGL}
\alias{predict.GIC.FuncompCGL}
\title{make predictions from a \code{"GIC.FuncompCGL"} object.}
\usage{
\method{predict}{GIC.FuncompCGL}(object, Znew, Zcnew = NULL, s = "lam.min",
  k = NULL, ...)
}
\arguments{
\item{object}{fitted \code{"GIC.FuncompCGL"} model}

\item{Znew}{new time-variate compositional data, stored as data frame}

\item{Zcnew}{new time-invariant covarites, stored as matrix}

\item{s}{\code{"lam.min"} or user provided value}

\item{k}{value of df of basis at which predictions are required. Default is the value of \code{k}
that gives minimum mean GIC value. If \code{k}
is a scaler, it is taken as the value of \code{k} to be used and it must be stored in
\code{\link{GIC.FuncompCGL}} object.}

\item{\dots}{Other arguments to predict.}
}
\description{
This function makes prediction from a GIC \code{FuncompCGL} model,
using the stored \code{Funcomp.CGL.fit} object and the optimal value chose for \code{lambda}.
}
\examples{
df_beta = 5
p = 30 #30
beta_C_true = matrix(0, nrow = p, ncol = df_beta)
beta_C_true[3, ] <- c(-1, 0, 0, 0, -0.5) #c(-0.5, 0, 0, 0, -0.5)
beta_C_true[1, ] <- c(1, 0, 1 , 0, -0.5) #c(0.5, 0, 1 , 0, -0.5)
beta_C_true[2, ] <- c(0, 0,  -1,  0,  1)

nfolds = 10
k_list <- c(4,5,6)
n_train = 100
n_test = 500

Data <- Model(n = n_train, p = p, m = 0, intercept = TRUE,
              SNR = 3, sigma = 3,
              rho_X = 0, rho_T = 0,
              Corr_X = "CorrCS", Corr_T = "CorrAR",
              df_beta = df_beta,
              n_T = 20, obs_spar = 1, theta.add = FALSE, #c(0,0,0),
              beta_C = as.vector(t(beta_C_true)))
y <- drop(Data$data$y)
n <- length(y)
X <- Data$data$Comp
Zc <- Data$data$Zc
intercept <- Data$data$intercept
m <- ifelse(is.null(Zc), 0, dim(Zc)[2]) #+ as.integer(intercept)
#m1 <- m + as.integer(intercept)
sseq <- Data$basis.info[,1]
beta_C.true <- matrix(Data$beta[1:(p*(df_beta))],
                      nrow = p, ncol = df_beta, byrow = TRUE)
beta_curve.true <- Data$basis.info[,-1] \%*\% t(beta_C.true)
Non_zero.true <- (1:p)[apply(beta_C.true, 1, function(x) max(abs(x)) > 0)]
foldid <- sample(rep(seq(nfolds), length = n))

arg_list <- as.list(Data$call)[-1]
arg_list$n <- n_test
Test <- do.call(Model, arg_list)
y_test <- drop(Test$data$y)



GIC_m1 <- GIC.FuncompCGL( y = y, X = X, Zc = Zc, ref = NULL,
                          inner_eps = 1e-8, outer_eps = 1e-8, tol = 1e-8,
                          k = k_list)
y_hat = predict(GIC_m1, Znew = Test$data$Comp, Zcnew = Test$data$Zc)

}
\seealso{
\code{\link{GIC.FuncompCGL}}
}
