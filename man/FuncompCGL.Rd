% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FuncompCGL.R
\name{FuncompCGL}
\alias{FuncompCGL}
\title{Fits regularization paths for longitudinal compositional data with group-lasso penalty.}
\usage{
FuncompCGL(y, X, Zc = NULL, intercept = TRUE, ref = NULL, k, degree = 3,
  basis_fun = c("bs", "OBasis", "fourier"), insert = c("FALSE", "X",
  "basis"), method = c("trapezoidal", "step"), interval = c("Original",
  "Standard"), Trange, T.name = "TIME", ID.name = "Subject_ID", W = rep(1,
  times = p - length(ref)), dfmax = p - length(ref), pfmax = min(dfmax *
  1.5, p - length(ref)), lam = NULL, nlam = 100, lambda.factor = ifelse(n
  < p1, 0.05, 0.001), tol = 0, mu_ratio = 1.01, outer_maxiter = 1e+08,
  outer_eps = 1e-08, inner_maxiter = 10000, inner_eps = 1e-08)
}
\arguments{
\item{y}{a vector of response variable.}

\item{X}{a data frame or matrix.
\itemize{
\item If \code{dim(X)[1]} > \eqn{n}, \eqn{n} is the sample size,
      \code{X} should be a data frame of longitudinal compositinal predictors with number \eqn{p},
      including subject ID and time variable. Order of subject ID should be the same as that of \code{y}.
\item If \code{dim(X)[1]}=\eqn{n}, \code{X} is considered as after taken integration, a \eqn{n*(p*k)} matrix.
}}

\item{Zc}{A design matrix for control variables, could be missing. Default is NULL. No penalty is imposed.}

\item{intercept}{whether to include intercept. Default is TRUE.}

\item{ref}{reference variable. If \code{ref} is set to a scalar between \code{[1,p]}, log-contract method is applied with the variable
\code{ref} as baseline. If \code{ref} = \code{NULL} (default value), constrained group lasso method is applied}

\item{k}{a scaler, degree of freedom of basis.}

\item{degree}{degree of basis - default value is 3.}

\item{basis_fun}{a function of basis. For now one of the following three types,
\itemize{
\item \code{bs} B-splines see \code{\link{bs}}.
\item \code{OBasis} Orthoganal B-splies, see \code{\link{orthogonalsplinebasis}}.
\item \code{fourier} Fourier basis, see \code{\link{fda}}
}
Default is \code{"bs"}.}

\item{insert}{way to interpolation. If \code{insert} = \code{"X"} or \code{"basis"}, dense time sequence is generated, equally space
by \code{min(diff(sseq))/20)}, where \code{sseq} is sorted set of all observed time points.
\itemize{
\item \code{"FALSE"} no interpolation.
\item \code{"X"} linear interpolation of compositional data.
\item \code{"basis"} compositional data is considered as step function, imposing basis on un-observed time points for each subject.
}
Default is \code{"FALSE"}}

\item{method}{method used to approximate integral.
\itemize{
\item \code{"trapezoidal"} Sum up area under trapezoidal formulated by values of function at two adjacent observed time points. See \code{\link{ITG_trap}}.
\item \code{"step"} Sum up area under rectangle formulated by step function at observed time points. See \code{\link{ITG_step}}.
}
Default is \code{"trapezoidal"}}

\item{interval}{a character string sepcifying domain of integral
\itemize{
  \item "Original" On original time scale, interval = range(Time).
  \item "Standard" Time points are mapped onto [0,1], interval = (0,1).
}
Default is \code{"Original"}}

\item{Trange}{range of time points}

\item{T.name, ID.name}{characters specifying names of time varaible and Subject ID respectively in X,
only needed as X is data frame of longitudinal compositinal varaibles.
Default are \code{"TIME"} and \code{"Subject_ID"}.}

\item{W}{a vector in length of p (the total number of groups), matrix with dimension \code{p1*p1} or character specifying function
used to calculate inverted weight matrix for each group.
\itemize{
\item If vector, works as penalty factor. Separate penalty weights can be applied to each group of beta'ss.
      to allow differential shrinkage. Can be 0 for some groups, which implies no shrinkage, and results in that group
      always being included in the model.
\item If matrix, a block diagonal matrix. Diagonal elements are inverted weights matrics for each group.
\item if character, user should provide the function for inverted weights matrics.
}
Default value is rep(1, times = p).}

\item{dfmax}{limit the maximum number of groups in the model. Useful for very large \eqn{p},
if a partial path is desired. Default is \eqn{p}.}

\item{pfmax}{limit the maximum number of groups ever to be nonzero. For example once a group enters the
model along the path, no matter how many times it exits or re-enters model through the path,
it will be counted only once. Default is \code{min(dfmax*1.5, p)}.}

\item{lam}{a user supplied lambda sequence. Typically, by leaving this option unspecified users can have the
program compute its own \code{lam} sequence based on \code{nlam} and \code{lambda.factor}.
Supplying a value of lambda overrides this.
If \code{lam} is provided but a scaler and \code{nlam}\eqn{>}1,
\code{lam} sequence is also created starting from \code{lam}.
If a sequence of lambda is provided, it is better to supply a decreasing one,
if not, the program will sort user-defined \code{lambda} sequence in decreasing order
automatically.}

\item{nlam}{the length of \code{lam} sequence. Default is 100.}

\item{lambda.factor}{the factor for getting the minimal lambda in \code{lam} sequence, where
\code{min(lam)} = \code{lambda.factor} * \code{max(lam)}.
\code{max(lam)} is the smallest value of \code{lam} for which all penalized group are zero's.
The default depends on the relationship between \eqn{n}
and \eqn{p1}
(the number of predictors to be penalized).
If \eqn{n >= p1}, the default is \code{0.001}, close to zero.
If \eqn{n < p1}, the default is \code{0.05}. A very small value of
\code{lambda.factor}
will lead to a saturated fit. It takes no effect if there is user-defined lambda sequence.}

\item{tol}{tolerance for vectors betas to be considered as none zero's. For example, coefficient
\eqn{\beta_j} for group j, if \eqn{max(abs(\beta_j))} < \code{tol}, set \eqn{\beta_j} as 0's.
Default value is 0.}

\item{mu_ratio}{\code{mu_ratio} is the increasing ratio for \code{u}. Default value is 1.01.
Inital values for scaled Lagrange multipliers are set as 0's.
If \code{mu_ratio} < 1,
there is no linear constraints included. Group lasso coefficients are estimated.}

\item{outer_maxiter}{\code{outer_maxiter} is the maximun munber of loops allowed for Augmented Lanrange method;
and \code{outer_eps} is the convergence termination tolerance.}

\item{outer_eps}{\code{outer_maxiter} is the maximun munber of loops allowed for Augmented Lanrange method;
and \code{outer_eps} is the convergence termination tolerance.}

\item{inner_maxiter}{\code{inner_maxiter} is the maximun munber of loops allowed for blockwise-GMD;
and \code{inner_eps} is the convergence termination tolerance.}

\item{inner_eps}{\code{inner_maxiter} is the maximun munber of loops allowed for blockwise-GMD;
and \code{inner_eps} is the convergence termination tolerance.}
}
\value{
An object with S3 calss \code{\link{FuncompCGL}}
\item{Z}{integral matrix for longitudinal compositinal predictors with dimension \eqn{n*(p*k)}.}
\item{lam}{the actual sequence of \code{lam} values used.}
\item{df}{the number of non-zero groups in estimated coefficients for \code{Z} at each value of \code{lam}}
\item{beta}{a matrix of coefficients for \code{cbind{Z, Zc, 1_n}}, with \code{nlam} rows.}
\item{dim}{dimension of coefficient matrix}
\item{call}{the call that produced this object.}
}
\description{
Fits regularization paths for longitudinal compositional data with group-lasso penalty at a sequence of regularization parameters lambda and fixed degree of freedom of basis.
}
\examples{

df_beta = 5
p = 30
beta_C_true = matrix(0, nrow = p, ncol = df_beta)
beta_C_true[3, ] <- c(-0.8, -0.8 , 0.4 , 1 , 1)
beta_C_true[4, ] <- c(0.5, 0.5, -0.6  ,-0.6, -0.6)
beta_C_true[1, ] <- c(-0.5, -0.5, -0.5 , -1, -1)
beta_C_true[2, ] <- c(0.8, 0.8,  0.7,  0.6,  0.6)
Data <- Model(n = 50, p = p, m = 2, intercept = TRUE,
              SNR = 2, sigma = 2,
              rho_X = 0, rho_T = 0.5, df_beta = df_beta,
              n_T = 20, obs_spar = 0.8, theta.add = c(3,4,5),
              beta_C = as.vector(t(beta_C_true)))
y <- Data$data$y
X <- Data$data$Comp
Zc <- Data$data$Zc
intercept <- Data$data$intercept

k_use <- df_beta
m1 <- FuncompCGL(y = y, X = X , Zc = Zc, intercept = intercept,
                 k = k_use, basis_fun = "bs",
                 insert = "FALSE", method = "t",
                 dfmax = p, tol = 1e-6)
print(m1)
beta <- coef(m1, s = m1$lam[20])
#beta <- coef(m1)

beta_C <- matrix(beta[1:(p*k_use)], nrow = p, byrow = TRUE)
colSums(beta_C)
Non.zero <- apply(beta_C, 1, function(x) ifelse(max(abs(x)) == 0, FALSE, TRUE))
Non.zero <- (1:p)[Non.zero]
Non.zero
plot(m1, ylab = "L2", p = p , k = k_use)

}
