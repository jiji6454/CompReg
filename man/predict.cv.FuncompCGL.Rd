% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{predict.cv.FuncompCGL}
\alias{predict.cv.FuncompCGL}
\title{make predictions from a "cv.FuncompCGL" object.}
\usage{
\method{predict}{cv.FuncompCGL}(object, Znew, Zcnew = NULL, s = c("lam.1se",
  "lam.min"), k = NULL, trim = FALSE, ...)
}
\arguments{
\item{object}{fitted \code{\link{cv.FuncompCGL}} object.}

\item{Znew}{Data frame of new values for functional compositional data at which predictions are to be made.}

\item{Zcnew}{Matrix of new values for time-invariant covariates data at which predictions are to be made.}

\item{s}{value(s) of the penalty parameter \code{lam} at which predictions are required.
Default is the value \code{s="lam.min"} stored on the CV \code{object}, it is the
value of \code{lam} for optimal \code{k} such that gives minimum mean cross-validated error.
If \code{s} is numeric, it is taken as the value(s) of \code{lam} to be used.}

\item{k}{value of df of basis at which predictions are required. Default is \code{k = "k.min"},
it is the value of \code{k} that gives minimum mean cross-validated error. If \code{k}
is a scaler, it is taken as the value of \code{k} to be used and it must be stored in
\code{\link{cv.FuncompCGL}} object.}

\item{trim}{logical, used the trimmed result or not.}

\item{...}{Other arguments are passed to \code{predict.FuncompCGL}}
}
\description{
This function makes prediction from a cross-validated \code{FuncompCGL} model,
using the stored \code{FuncompCGL.fit} object and the optimal value chose for \code{lambda}.
}
\examples{
df_beta = 5
p = 30
beta_C_true = matrix(0, nrow = p, ncol = df_beta)
beta_C_true[3, ] <- c(-1, 0, 0, 0, -0.5)
beta_C_true[1, ] <- c(1, 0, 1 , 0, -0.5)
beta_C_true[2, ] <- c(0, 0,  -1,  0,  1)

nfolds = 10
k_list <- c(4,5,6)
n_train = 100
n_test = 500

Data <- Model(n = n_train, p = p, m = 0, intercept = TRUE,
              SNR = 2, sigma = 2,
              rho_X = 0, rho_T = 0.5,
              Corr_X = "CorrCS",
              df_beta = df_beta,
              n_T = 20, obs_spar = 1, theta.add = FALSE, #c(0,0,0),
              beta_C = as.vector(t(beta_C_true)))
y <- drop(Data$data$y)
n <- length(y)
X <- Data$data$Comp
Zc <- Data$data$Zc
intercept <- Data$data$intercept
m <- ifelse(is.null(Zc), 0, dim(Zc)[2])
arg_list <- as.list(Data$call)[-1]
arg_list$n <- n_test
Test <- do.call(Model, arg_list)
rule <- "lam.min"
# cv_cgl, Constrained group lasso
cv_cgl <-  cv.FuncompCGL(y = y, X = X, Zc = Zc, intercept = intercept,
                         W = rep(1, p), #W = function(x){ diag( 1 / apply(x, 2, sd) ) },
                         k = k_list, trim = 0,
                         nfolds = 10,
                         tol = 0, inner_eps = 1e-6, inner_maxiter = 1E3,
                         dfmax = 30, lambda.factor = 1e-3,
                         mu_ratio = 1, outer_eps = 1e-6,
                         keep = TRUE, Trange = c(0,1))
y_hat = predict(cv_cgl, Znew = Test$data$Comp, Zcnew = Test$data$Zc)

}
\seealso{
\code{\link{FuncompCGL}}
}
