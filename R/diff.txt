diff --git a/R/tools.R b/R/tools.R
index b1149a2..a5fb8da 100644
--- a/R/tools.R
+++ b/R/tools.R
@@ -143,7 +143,6 @@ coef.compCL <- function(object, s = NULL, ...) {
 #' @return
 #' prediction values at the requested values for \code{s}.
 #'
-#' @export
 #'
 #' @importFrom methods cbind2
 #'
@@ -151,8 +150,26 @@ coef.compCL <- function(object, s = NULL, ...) {
 
 predict.FuncompCGL <- function(object, newx, s = NULL, ...) {
   beta <- object$beta
+
+  ## >>> Data pre-coding: integral <<<
+  #if(nrow(beta) -1 != ncol(newx) )
+
+  if(is.list(newx)) {
+    ## if newx is the raw data
+    ## newx = list(Comp = Comp, Zc = Zc)
+    ## composition is data.frame of longitudinal composition data and Zc is the matrix of time-invariant covariates
+    list_param = as.list(object$call)
+  } else {
+    ## if new is the pre-coding data
+    ## newx is the cbind(Z, Zc)
+    ## Z is the matrix integral of compositional covariates
+  }
+  ## <<< Data pre-coding: integral >>>
+
+  ## >>> Take Extraction: lambda and beta <<<
   if (!is.null(s)) {
     lam <- object$lam
+    # linear interpolating s in lambda sequence
     lamlist <- point.interp(lam, s)
     if(length(s) == 1)
     {
@@ -164,8 +181,13 @@ predict.FuncompCGL <- function(object, newx, s = NULL, ...) {
     }
     #dimnames(beta) <- list(vnames, paste(seq(along = s)))
   }
+  ## <<< Take Extraction: lambda and beta >>>
+
+  ## >>> Make prediction: matrix mutiplication <<<
   if (is.null(dim(newx))) newx = matrix(newx, nrow = 1)
   fitting <- cbind2(newx, 1) %*% beta #as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta)
+  ## <<< Make prediction: matrix mutiplication >>>
+
   return(fitting)
 }
 
@@ -215,11 +237,27 @@ predict.compCL <- function(object, Znew, Zcnew = NULL,  s = NULL, ...) {
   #print(object$beta)
   beta <- object$beta
   nvars <- dim(beta)[1] - 1
+
+  # >>> predictors <<<
+  ## Znew
   if( is.null(dim(Znew)) ) Znew = matrix(Znew, nrow = 1)
+
+  if( any(abs(rowSums(Znew) - 1) > 1e-10) ) {
+    message("Z is transformed into compositional data by deviding rowSums")
+    Znew <- Znew / rowSums(Znew)
+  }
+  if(any(Znew == 0)) stop("There is zero entry in compositional data")
+  Znew <- log(Znew)
+
+  ## Zcnew
   if( !is.null(Zcnew) && is.null(dim(Zcnew)) ) Zcnew = matrix(Zcnew, nrow = 1)
   new <- cbind(Znew, Zcnew)
+  ## <<< predictors >>>
+
   if( nvars != dim(new)[2] ) stop("numbers of variables in data is not consistant with estimated coefficients")
 
+
+  # >>> beta <<<
   if (!is.null(s)) {
     lam <- object$lam
     lamlist <- point.interp(lam, s)
@@ -232,6 +270,7 @@ predict.compCL <- function(object, Znew, Zcnew = NULL,  s = NULL, ...) {
     }
     colnames(beta) <- paste(seq(along = s))
   }
+  # <<< beta >>>
 
   #colnames(beta) <- paste(seq(along = 1:dim(beta)[2]))
   fitting <- cbind2(new, 1) %*% beta   #as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta)
@@ -498,21 +537,20 @@ coef.cv.compCL <- function(object, trim = FALSE, s = c("lam.min", "lam.1se" ),..
 #' @export
 
 predict.cv.compCL <- function(object, Znew, Zcnew = NULL, s = c("lam.min", "lam.1se" ), trim = FALSE, ...){
-  trim <- ifelse(trim, "Ttrim", "Ftrim")
-  object_use <- object[[trim]]
-  if (is.numeric(s)) {
+ if (is.numeric(s)) {
     lam <- s
   } else if (is.character(s)) {
     s <- match.arg(s)
     # switch(s,
     #           "lam.min" = "lambda.min",
     #           "lam.1se" = "lambda.1se")
-    lam <- object_use[[s]]
+    trim <- ifelse(trim, "Ttrim", "Ftrim")
+    lam_use <- object[[trim]]
+    lam <- lam_use[[s]]
   } else {
     stop("Invalid form for s")
   }
-
-  predict(object_use, Znew=Znew, Zcnew = Zcnew, s = lam, ...)
+  predict(object$compCL.fit, Znew=Znew, Zcnew = Zcnew, s = lam, ...)
 }
 
 
@@ -642,10 +680,10 @@ plot.FuncompCGL <- function(x, p, k,
 #' @export
 #'
 
-plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
+plot.compCL <- function(x, xlab=c("norm", "log"), label=FALSE, ...) {
   xlab <-  match.arg(xlab)
   beta <- x$beta
-  lambda <- x$lambda
+  lambda <- x$lam
   df <- x$df
   nr = nrow(beta)
   if(nr == 1) {
@@ -656,8 +694,8 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
     # ones <- rep(1, ncol(beta))
     # nz = as.vector((beta %*% ones) > 0)
     # index_which = index_which[nz]
-    index_which <- apply(beta, 1, function(x) ifelse(any(abs(beta)) > 0, TRUE, FALSE))
-    index_which <- seq(ncol(beta))[index_which]
+    index_which <- apply(beta, 1, function(x) ifelse(any(abs(x) > 0), TRUE, FALSE))
+    index_which <- seq(nrow(beta))[index_which]
   }
 
   nwhich = length(index_which)
@@ -667,7 +705,7 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
     return()
   }
 
-  beta = as.matrix(beta[which, , drop=FALSE])
+  beta = as.matrix(beta[index_which, , drop=FALSE])
   name_ylab = "Coefficients"
   switch(xlab,
          "norm" = {
@@ -675,7 +713,7 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
            name_xlab = "L1 Norm"
            approx.f = 1
          },
-         "lambda" = {
+         "log" = {
            index_xlab = log(lambda)
            name_xlab = "log Lambda"
            approx.f = 0
@@ -699,13 +737,13 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
              xpos = max(index_xlab)
              pos = 4
            },
-           "lambda" = {
+           "log" = {
              xpos = min(index_xlab)
              pos = 2
            })
-    pos_xlab = rep(xpos, length(which))
+    pos_xlab = rep(xpos, nwhich)
     pos_ylab = beta[, ncol(beta)]
-    text(pos_xlab, pos_ylab, paste(which), cex = 0.5, pos = pos)
+    text(pos_xlab, pos_ylab, paste(index_which), cex = 0.8, pos = pos)
   }
 }
 
@@ -727,6 +765,7 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
 
 
 
+
 
 
 
@@ -844,7 +883,7 @@ plot.cv.FuncompCGL <- function(x, xlab = c("log", "lambda"),
                width=0.01,col="red")
   }
 
- 
+
 
 
 
@@ -896,7 +935,7 @@ plot.cv.FuncompCGL <- function(x, xlab = c("log", "lambda"),
          lty = 3, col = "red"
   )
 
-  
+
 
 }
 
@@ -920,19 +959,23 @@ plot.cv.FuncompCGL <- function(x, xlab = c("log", "lambda"),
 #'
 
 
-plot.cv.compCL <- function(x, xlab = c("log", "lambda"), ...) {
+plot.cv.compCL <- function(x, xlab = c("log", "-log", "lambda"), ...) {
   cvobj <- x
   xlab <- match.arg(xlab)
   #trim <- ifelse(trim, "Ttrim", "Ftrim")
   cvobj_use <- cvobj[["Ftrim"]]
   switch(xlab,
+        "log" = {
+           xlab = "Log(Lambda)"
+           xvalue = log(drop(cvobj$lam))
+         },
+         "-log" = {
+           xlab = "-Log(Lambda)"
+           xvalue = -log(drop(cvobj$lam))
+         },
          "lambda" = {
            xlab = "Lambda"
            xvalue = drop(cvobj$lam)
-         },
-         "log" = {
-           xlab = "Log(Lambda)"
-           xvalue = log(drop(cvobj$lam))
          })
 
 
@@ -948,15 +991,17 @@ plot.cv.compCL <- function(x, xlab = c("log", "lambda"), ...) {
   points(xvalue,cvobj_use$cvm,pch=20,col="limegreen")
   axis(side=3,at=xvalue,labels=paste(cvobj$compCL.fit$df),tick=FALSE,line=0)
   abline(v = switch(xlab,
-                    "Lambda" = cvobj_use$lam.1se,
-                    "Log(Lambda)" = log(cvobj_use$lam.1se)
-  ),lty=3, col = "blue")
+                   "Log(Lambda)" = log(cvobj_use$lam.1se),
+                   "-Log(Lambda)" = -log(cvobj_use$lam.1se),
+                   "Lambda" = cvobj_use$lam.1se),
+        lty=3, col = "blue")
   abline(v=switch(xlab,
-                  "Lambda" = cvobj_use$lam.min,
-                  "Log(Lambda)" = log(cvobj_use$lam.min)
-  ), lty=3, col = "red")
- 
-  invisible()
+                 "Log(Lambda)" = log(cvobj_use$lam.min),
+                 "-Log(Lambda)" = -log(cvobj_use$lam.min),
+                 "Lambda" = cvobj_use$lam.min),
+        lty=3, col = "red")
+
+  #invisible()
 }
 
 
@@ -1077,8 +1122,7 @@ coef.GIC.compCL <- function(object, s = "lam.min",...) {
 #' @export
 
 
-predict.GIC.compCL <- 
-  function(object, Znew, Zcnew = NULL, s = "lam.min", ...){
+predict.GIC.compCL <- function(object, Znew, Zcnew = NULL, s = "lam.min", ...){
   if (is.numeric(s)) {
     lam <- s
   } else if (s == "lam.min") {
@@ -1086,7 +1130,7 @@ predict.GIC.compCL <-
   } else {
     stop("Invalid form for s")
   }
-  
+
   predict(object$compCL.fit, Znew=Znew, Zcnew = Zcnew, s = lam, ...)
 }
 
@@ -1184,14 +1228,13 @@ predict.GIC.compCL <-
 #' A plot is produced, and nothing is returned.
 #'
 #' @export
-#' 
-#' 
+#'
+#'
 
 
 plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
                                 k_list, ...) {
-  ## >>> x-axis <<< 
-  print("A")
+  ## >>> x-axis <<<
   xlab <- match.arg(xlab)
   switch(xlab,
          "lambda" = {
@@ -1206,9 +1249,9 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
             xlab = "-Log(Lambda)"
             xvalue = -log(drop(x$lam))
           })
-  
-  ## <<< x-axis >>> 
-  
+
+  ## <<< x-axis >>>
+
   ## >>> K list <<<
   k_listall <- as.numeric(names(x$Funcomp.CGL.fit))
   k_opt <- x$lammin['df']
@@ -1217,14 +1260,14 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
     k_list <- k_list[k_list %in% k_listall]
     if(!(k_opt %in% k_list)) warning("Optimal df 'k' is not included in the provied 'k_list' ")
   }
-  
+
   k_list <- c(k_list[k_opt == k_list], k_list[k_opt != k_list])
   ## <<< K list >>>
-  
-  
+
+
   N_list <- apply(x$GIC[k_list- k_listall[1] + 1, , drop = FALSE], 1, function(x) length(x[!is.na(x)]))
-  
-  
+
+
   ## >>> plot <<<
   plot.args = list(x = xvalue[seq(max(N_list))], xlab = xlab,
                    y = x$GIC[k_list[which.max(N_list)] - k_listall[1] + 1, seq(max(N_list))],
@@ -1238,14 +1281,12 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
 
   if(length(new.args)) plot.args[names(new.args)] = new.args
   do.call("plot", plot.args)
-  
+
   pch_list = c(0, seq(length(k_list))[-1])
   col_list = rainbow(length(k_list)+1)[-1]
-  
+
   for(l in 1:length(k_list)) {
     if(k_list[l] != k_opt) {
-      print(l)
-      print(pch_list[l])
       points(xvalue,
              x$GIC[k_list[l] - k_listall[1] + 1, ],
              pch = pch_list[l],
@@ -1269,7 +1310,7 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
             lty = 3, col = "red")
     }
   }
-  
+
   if(k_opt %in% k_list){
     if(length(k_list) > 1) {
       legend(switch(xlab,
@@ -1291,11 +1332,11 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
              inset = 0.03,
              legend = paste("k", k_opt, sep = "="),
              col = "red",
-             pch = 1, 
+             pch = 1,
              cex = 0.8, box.lty = 0
       )
     }
-      
+
   } else {
     legend(switch(xlab,
                   "Log(Lambda)" = "topright",
@@ -1307,7 +1348,7 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
            pch = pch_list,
            cex = 0.8, box.lty = 0
     )
-    
+
   }
   ## <<< plot >>>
   invisible()
@@ -1347,8 +1388,8 @@ plot.GIC.compCL <- function(x, xlab = c("log", "-log", "lambda"), ...) {
            xlab = "-Log(Lambda)"
            xvalue = -log(drop(x$lam))
          })
-  
-  
+
+
   plot.args = list(x = xvalue,y = x$GIC,
                    ylim = range(x$GIC),
                    xlab=xlab,
@@ -1359,12 +1400,12 @@ plot.GIC.compCL <- function(x, xlab = c("log", "-log", "lambda"), ...) {
   do.call("plot",plot.args)
   points(xvalue, x$GIC)
   axis(side=3,at=xvalue,labels=paste(x$compCL.fit$df),tick=FALSE,line=0)
-  
+
   abline(v=switch(xlab,
                   "Lambda" = x$lam.min,
                   "Log(Lambda)" = log(x$lam.min),
                   "-Log(Lambda)" = -log(x$lam.min)
   ), lty=3, col = "red")
-  
+
   invisible()
-}
\ No newline at end of file
+}
diff --git a/R/tools.R b/R/tools.R
index b1149a2..a5fb8da 100644
--- a/R/tools.R
+++ b/R/tools.R
@@ -143,7 +143,6 @@ coef.compCL <- function(object, s = NULL, ...) {
 #' @return
 #' prediction values at the requested values for \code{s}.
 #'
-#' @export
 #'
 #' @importFrom methods cbind2
 #'
@@ -151,8 +150,26 @@ coef.compCL <- function(object, s = NULL, ...) {
 
 predict.FuncompCGL <- function(object, newx, s = NULL, ...) {
   beta <- object$beta
+
+  ## >>> Data pre-coding: integral <<<
+  #if(nrow(beta) -1 != ncol(newx) )
+
+  if(is.list(newx)) {
+    ## if newx is the raw data
+    ## newx = list(Comp = Comp, Zc = Zc)
+    ## composition is data.frame of longitudinal composition data and Zc is the matrix of time-invariant covariates
+    list_param = as.list(object$call)
+  } else {
+    ## if new is the pre-coding data
+    ## newx is the cbind(Z, Zc)
+    ## Z is the matrix integral of compositional covariates
+  }
+  ## <<< Data pre-coding: integral >>>
+
+  ## >>> Take Extraction: lambda and beta <<<
   if (!is.null(s)) {
     lam <- object$lam
+    # linear interpolating s in lambda sequence
     lamlist <- point.interp(lam, s)
     if(length(s) == 1)
     {
@@ -164,8 +181,13 @@ predict.FuncompCGL <- function(object, newx, s = NULL, ...) {
     }
     #dimnames(beta) <- list(vnames, paste(seq(along = s)))
   }
+  ## <<< Take Extraction: lambda and beta >>>
+
+  ## >>> Make prediction: matrix mutiplication <<<
   if (is.null(dim(newx))) newx = matrix(newx, nrow = 1)
   fitting <- cbind2(newx, 1) %*% beta #as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta)
+  ## <<< Make prediction: matrix mutiplication >>>
+
   return(fitting)
 }
 
@@ -215,11 +237,27 @@ predict.compCL <- function(object, Znew, Zcnew = NULL,  s = NULL, ...) {
   #print(object$beta)
   beta <- object$beta
   nvars <- dim(beta)[1] - 1
+
+  # >>> predictors <<<
+  ## Znew
   if( is.null(dim(Znew)) ) Znew = matrix(Znew, nrow = 1)
+
+  if( any(abs(rowSums(Znew) - 1) > 1e-10) ) {
+    message("Z is transformed into compositional data by deviding rowSums")
+    Znew <- Znew / rowSums(Znew)
+  }
+  if(any(Znew == 0)) stop("There is zero entry in compositional data")
+  Znew <- log(Znew)
+
+  ## Zcnew
   if( !is.null(Zcnew) && is.null(dim(Zcnew)) ) Zcnew = matrix(Zcnew, nrow = 1)
   new <- cbind(Znew, Zcnew)
+  ## <<< predictors >>>
+
   if( nvars != dim(new)[2] ) stop("numbers of variables in data is not consistant with estimated coefficients")
 
+
+  # >>> beta <<<
   if (!is.null(s)) {
     lam <- object$lam
     lamlist <- point.interp(lam, s)
@@ -232,6 +270,7 @@ predict.compCL <- function(object, Znew, Zcnew = NULL,  s = NULL, ...) {
     }
     colnames(beta) <- paste(seq(along = s))
   }
+  # <<< beta >>>
 
   #colnames(beta) <- paste(seq(along = 1:dim(beta)[2]))
   fitting <- cbind2(new, 1) %*% beta   #as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta)
@@ -498,21 +537,20 @@ coef.cv.compCL <- function(object, trim = FALSE, s = c("lam.min", "lam.1se" ),..
 #' @export
 
 predict.cv.compCL <- function(object, Znew, Zcnew = NULL, s = c("lam.min", "lam.1se" ), trim = FALSE, ...){
-  trim <- ifelse(trim, "Ttrim", "Ftrim")
-  object_use <- object[[trim]]
-  if (is.numeric(s)) {
+ if (is.numeric(s)) {
     lam <- s
   } else if (is.character(s)) {
     s <- match.arg(s)
     # switch(s,
     #           "lam.min" = "lambda.min",
     #           "lam.1se" = "lambda.1se")
-    lam <- object_use[[s]]
+    trim <- ifelse(trim, "Ttrim", "Ftrim")
+    lam_use <- object[[trim]]
+    lam <- lam_use[[s]]
   } else {
     stop("Invalid form for s")
   }
-
-  predict(object_use, Znew=Znew, Zcnew = Zcnew, s = lam, ...)
+  predict(object$compCL.fit, Znew=Znew, Zcnew = Zcnew, s = lam, ...)
 }
 
 
@@ -642,10 +680,10 @@ plot.FuncompCGL <- function(x, p, k,
 #' @export
 #'
 
-plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
+plot.compCL <- function(x, xlab=c("norm", "log"), label=FALSE, ...) {
   xlab <-  match.arg(xlab)
   beta <- x$beta
-  lambda <- x$lambda
+  lambda <- x$lam
   df <- x$df
   nr = nrow(beta)
   if(nr == 1) {
@@ -656,8 +694,8 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
     # ones <- rep(1, ncol(beta))
     # nz = as.vector((beta %*% ones) > 0)
     # index_which = index_which[nz]
-    index_which <- apply(beta, 1, function(x) ifelse(any(abs(beta)) > 0, TRUE, FALSE))
-    index_which <- seq(ncol(beta))[index_which]
+    index_which <- apply(beta, 1, function(x) ifelse(any(abs(x) > 0), TRUE, FALSE))
+    index_which <- seq(nrow(beta))[index_which]
   }
 
   nwhich = length(index_which)
@@ -667,7 +705,7 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
     return()
   }
 
-  beta = as.matrix(beta[which, , drop=FALSE])
+  beta = as.matrix(beta[index_which, , drop=FALSE])
   name_ylab = "Coefficients"
   switch(xlab,
          "norm" = {
@@ -675,7 +713,7 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
            name_xlab = "L1 Norm"
            approx.f = 1
          },
-         "lambda" = {
+         "log" = {
            index_xlab = log(lambda)
            name_xlab = "log Lambda"
            approx.f = 0
@@ -699,13 +737,13 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
              xpos = max(index_xlab)
              pos = 4
            },
-           "lambda" = {
+           "log" = {
              xpos = min(index_xlab)
              pos = 2
            })
-    pos_xlab = rep(xpos, length(which))
+    pos_xlab = rep(xpos, nwhich)
     pos_ylab = beta[, ncol(beta)]
-    text(pos_xlab, pos_ylab, paste(which), cex = 0.5, pos = pos)
+    text(pos_xlab, pos_ylab, paste(index_which), cex = 0.8, pos = pos)
   }
 }
 
@@ -727,6 +765,7 @@ plot.compCL <- function(x, xlab=c("norm", "lambda"), label=FALSE, ...) {
 
 
 
+
 
 
 
@@ -844,7 +883,7 @@ plot.cv.FuncompCGL <- function(x, xlab = c("log", "lambda"),
                width=0.01,col="red")
   }
 
- 
+
 
 
 
@@ -896,7 +935,7 @@ plot.cv.FuncompCGL <- function(x, xlab = c("log", "lambda"),
          lty = 3, col = "red"
   )
 
-  
+
 
 }
 
@@ -920,19 +959,23 @@ plot.cv.FuncompCGL <- function(x, xlab = c("log", "lambda"),
 #'
 
 
-plot.cv.compCL <- function(x, xlab = c("log", "lambda"), ...) {
+plot.cv.compCL <- function(x, xlab = c("log", "-log", "lambda"), ...) {
   cvobj <- x
   xlab <- match.arg(xlab)
   #trim <- ifelse(trim, "Ttrim", "Ftrim")
   cvobj_use <- cvobj[["Ftrim"]]
   switch(xlab,
+        "log" = {
+           xlab = "Log(Lambda)"
+           xvalue = log(drop(cvobj$lam))
+         },
+         "-log" = {
+           xlab = "-Log(Lambda)"
+           xvalue = -log(drop(cvobj$lam))
+         },
          "lambda" = {
            xlab = "Lambda"
            xvalue = drop(cvobj$lam)
-         },
-         "log" = {
-           xlab = "Log(Lambda)"
-           xvalue = log(drop(cvobj$lam))
          })
 
 
@@ -948,15 +991,17 @@ plot.cv.compCL <- function(x, xlab = c("log", "lambda"), ...) {
   points(xvalue,cvobj_use$cvm,pch=20,col="limegreen")
   axis(side=3,at=xvalue,labels=paste(cvobj$compCL.fit$df),tick=FALSE,line=0)
   abline(v = switch(xlab,
-                    "Lambda" = cvobj_use$lam.1se,
-                    "Log(Lambda)" = log(cvobj_use$lam.1se)
-  ),lty=3, col = "blue")
+                   "Log(Lambda)" = log(cvobj_use$lam.1se),
+                   "-Log(Lambda)" = -log(cvobj_use$lam.1se),
+                   "Lambda" = cvobj_use$lam.1se),
+        lty=3, col = "blue")
   abline(v=switch(xlab,
-                  "Lambda" = cvobj_use$lam.min,
-                  "Log(Lambda)" = log(cvobj_use$lam.min)
-  ), lty=3, col = "red")
- 
-  invisible()
+                 "Log(Lambda)" = log(cvobj_use$lam.min),
+                 "-Log(Lambda)" = -log(cvobj_use$lam.min),
+                 "Lambda" = cvobj_use$lam.min),
+        lty=3, col = "red")
+
+  #invisible()
 }
 
 
@@ -1077,8 +1122,7 @@ coef.GIC.compCL <- function(object, s = "lam.min",...) {
 #' @export
 
 
-predict.GIC.compCL <- 
-  function(object, Znew, Zcnew = NULL, s = "lam.min", ...){
+predict.GIC.compCL <- function(object, Znew, Zcnew = NULL, s = "lam.min", ...){
   if (is.numeric(s)) {
     lam <- s
   } else if (s == "lam.min") {
@@ -1086,7 +1130,7 @@ predict.GIC.compCL <-
   } else {
     stop("Invalid form for s")
   }
-  
+
   predict(object$compCL.fit, Znew=Znew, Zcnew = Zcnew, s = lam, ...)
 }
 
@@ -1184,14 +1228,13 @@ predict.GIC.compCL <-
 #' A plot is produced, and nothing is returned.
 #'
 #' @export
-#' 
-#' 
+#'
+#'
 
 
 plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
                                 k_list, ...) {
-  ## >>> x-axis <<< 
-  print("A")
+  ## >>> x-axis <<<
   xlab <- match.arg(xlab)
   switch(xlab,
          "lambda" = {
@@ -1206,9 +1249,9 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
             xlab = "-Log(Lambda)"
             xvalue = -log(drop(x$lam))
           })
-  
-  ## <<< x-axis >>> 
-  
+
+  ## <<< x-axis >>>
+
   ## >>> K list <<<
   k_listall <- as.numeric(names(x$Funcomp.CGL.fit))
   k_opt <- x$lammin['df']
@@ -1217,14 +1260,14 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
     k_list <- k_list[k_list %in% k_listall]
     if(!(k_opt %in% k_list)) warning("Optimal df 'k' is not included in the provied 'k_list' ")
   }
-  
+
   k_list <- c(k_list[k_opt == k_list], k_list[k_opt != k_list])
   ## <<< K list >>>
-  
-  
+
+
   N_list <- apply(x$GIC[k_list- k_listall[1] + 1, , drop = FALSE], 1, function(x) length(x[!is.na(x)]))
-  
-  
+
+
   ## >>> plot <<<
   plot.args = list(x = xvalue[seq(max(N_list))], xlab = xlab,
                    y = x$GIC[k_list[which.max(N_list)] - k_listall[1] + 1, seq(max(N_list))],
@@ -1238,14 +1281,12 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
 
   if(length(new.args)) plot.args[names(new.args)] = new.args
   do.call("plot", plot.args)
-  
+
   pch_list = c(0, seq(length(k_list))[-1])
   col_list = rainbow(length(k_list)+1)[-1]
-  
+
   for(l in 1:length(k_list)) {
     if(k_list[l] != k_opt) {
-      print(l)
-      print(pch_list[l])
       points(xvalue,
              x$GIC[k_list[l] - k_listall[1] + 1, ],
              pch = pch_list[l],
@@ -1269,7 +1310,7 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
             lty = 3, col = "red")
     }
   }
-  
+
   if(k_opt %in% k_list){
     if(length(k_list) > 1) {
       legend(switch(xlab,
@@ -1291,11 +1332,11 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
              inset = 0.03,
              legend = paste("k", k_opt, sep = "="),
              col = "red",
-             pch = 1, 
+             pch = 1,
              cex = 0.8, box.lty = 0
       )
     }
-      
+
   } else {
     legend(switch(xlab,
                   "Log(Lambda)" = "topright",
@@ -1307,7 +1348,7 @@ plot.GIC.FuncompCGL <- function(x, xlab = c("log", "-log", "lambda"),
            pch = pch_list,
            cex = 0.8, box.lty = 0
     )
-    
+
   }
   ## <<< plot >>>
   invisible()
@@ -1347,8 +1388,8 @@ plot.GIC.compCL <- function(x, xlab = c("log", "-log", "lambda"), ...) {
            xlab = "-Log(Lambda)"
            xvalue = -log(drop(x$lam))
          })
-  
-  
+
+
   plot.args = list(x = xvalue,y = x$GIC,
                    ylim = range(x$GIC),
                    xlab=xlab,
@@ -1359,12 +1400,12 @@ plot.GIC.compCL <- function(x, xlab = c("log", "-log", "lambda"), ...) {
   do.call("plot",plot.args)
   points(xvalue, x$GIC)
   axis(side=3,at=xvalue,labels=paste(x$compCL.fit$df),tick=FALSE,line=0)
-  
+
   abline(v=switch(xlab,
                   "Lambda" = x$lam.min,
                   "Log(Lambda)" = log(x$lam.min),
                   "-Log(Lambda)" = -log(x$lam.min)
   ), lty=3, col = "red")
-  
+
   invisible()
-}
\ No newline at end of file
+}
